#!/usr/bin/env python3
import json
import os
import re
import argparse
from typing import List, Tuple, Optional

BEGINNING_OF_FILE = """// DO NOT MODIFY THIS FILE!  autogenerated by scripts/itemdata.py
#include "../../include/types.h"
#include "../../include/item.h"
#include "../../include/constants/hold_item_effects.h"
#include "../../include/constants/item.h"
#include "../../include/battle.h"


u32 __size = sizeof(ITEMDATA);


const ITEMDATA __data[] =
{
"""

END_OF_FILE = """
};
"""

DEFINE_RE = re.compile(r'^\s*#\s*define\s+(ITEM_[A-Z0-9_]+)\s+(\d+)\b')
ENUM_START_RE = re.compile(r'^\s*(typedef\s+)?enum\b')
ENUM_ITEM_RE = re.compile(r'^\s*(ITEM_[A-Z0-9_]+)\s*(=\s*([0-9]+))?\s*,?\s*(//.*)?$')
ENUM_END_RE = re.compile(r'^\s*}\s*;')


def parse_item_constants(header_path: str) -> List[Tuple[str, int]]:
    """Return ordered list of (ITEM_NAME, number) from #defines or enum."""
    with open(header_path, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    defines: List[Tuple[str, int]] = []
    for line in lines:
        m = DEFINE_RE.match(line)
        if m:
            defines.append((m.group(1), int(m.group(2))))
    if defines:
        defines.sort(key=lambda x: x[1])
        return defines

    items: List[Tuple[str, Optional[int]]] = []
    in_enum = False
    current = None
    for line in lines:
        if not in_enum and ENUM_START_RE.search(line):
            in_enum = True
            current = None
            continue
        if in_enum:
            if ENUM_END_RE.search(line):
                in_enum = False
                break
            m = ENUM_ITEM_RE.match(line)
            if m:
                name = m.group(1)
                explicit = m.group(3)
                if explicit is not None:
                    current = int(explicit)
                else:
                    current = 0 if current is None else current + 1
                if name.startswith("ITEM_"):
                    items.append((name, current))
    items.sort(key=lambda x: x[1])
    return [(n, int(v)) for (n, v) in items]


def folder_name_from_item(item_name: str) -> str:
    name = re.sub(r"^ITEM_", "", (item_name or "").strip())
    return re.sub(r"[^\w\-\.]", "_", name).lower()


def emit_value(v):
    if isinstance(v, str):
        return v
    if isinstance(v, bool):
        return "TRUE" if v else "FALSE"
    return str(v)


def emit_item_block(item_macro: str, obj: dict) -> str:
    p = obj
    u = p["partyUseParam"]
    return f"""
[{item_macro}] =
{{
    .price = {emit_value(p["price"])},
    .holdEffect = {emit_value(p["holdEffect"])},
    .holdEffectParam = {emit_value(p["holdEffectParam"])},
    .pluckEffect = {emit_value(p["pluckEffect"])},
    .flingEffect = {emit_value(p["flingEffect"])},
    .flingPower = {emit_value(p["flingPower"])},
    .naturalGiftPower = {emit_value(p["naturalGiftPower"])},
    .naturalGiftType = {emit_value(p["naturalGiftType"])},
    .prevent_toss = {emit_value(p["prevent_toss"])},
    .selectable = {emit_value(p["selectable"])},
    .fieldPocket = {emit_value(p["fieldPocket"])},
    .battlePocket = {emit_value(p["battlePocket"])},
    .fieldUseFunc = {emit_value(p["fieldUseFunc"])},
    .battleUseFunc = {emit_value(p["battleUseFunc"])},
    .partyUse = {emit_value(p["partyUse"])},
    .partyUseParam = {{
        .slp_heal = {emit_value(u["slp_heal"])},
        .psn_heal = {emit_value(u["psn_heal"])},
        .brn_heal = {emit_value(u["brn_heal"])},
        .frz_heal = {emit_value(u["frz_heal"])},
        .prz_heal = {emit_value(u["prz_heal"])},
        .cfs_heal = {emit_value(u["cfs_heal"])},
        .inf_heal = {emit_value(u["inf_heal"])},
        .guard_spec = {emit_value(u["guard_spec"])},
        .revive = {emit_value(u["revive"])},
        .revive_all = {emit_value(u["revive_all"])},
        .level_up = {emit_value(u["level_up"])},
        .evolve = {emit_value(u["evolve"])},
        .atk_stages = {emit_value(u["atk_stages"])},
        .def_stages = {emit_value(u["def_stages"])},
        .spatk_stages = {emit_value(u["spatk_stages"])},
        .spdef_stages = {emit_value(u["spdef_stages"])},
        .speed_stages = {emit_value(u["speed_stages"])},
        .accuracy_stages = {emit_value(u["accuracy_stages"])},
        .critrate_stages = {emit_value(u["critrate_stages"])},
        .pp_up = {emit_value(u["pp_up"])},
        .pp_max = {emit_value(u["pp_max"])},
        .pp_restore = {emit_value(u["pp_restore"])},
        .pp_restore_all = {emit_value(u["pp_restore_all"])},
        .hp_restore = {emit_value(u["hp_restore"])},
        .hp_ev_up = {emit_value(u["hp_ev_up"])},
        .atk_ev_up = {emit_value(u["atk_ev_up"])},
        .def_ev_up = {emit_value(u["def_ev_up"])},
        .speed_ev_up = {emit_value(u["speed_ev_up"])},
        .spatk_ev_up = {emit_value(u["spatk_ev_up"])},
        .spdef_ev_up = {emit_value(u["spdef_ev_up"])},
        .friendship_mod_lo = {emit_value(u["friendship_mod_lo"])},
        .friendship_mod_med = {emit_value(u["friendship_mod_med"])},
        .friendship_mod_hi = {emit_value(u["friendship_mod_hi"])},
        .hp_ev_up_param = {emit_value(u["hp_ev_up_param"])},
        .atk_ev_up_param = {emit_value(u["atk_ev_up_param"])},
        .def_ev_up_param = {emit_value(u["def_ev_up_param"])},
        .speed_ev_up_param = {emit_value(u["speed_ev_up_param"])},
        .spatk_ev_up_param = {emit_value(u["spatk_ev_up_param"])},
        .spdef_ev_up_param = {emit_value(u["spdef_ev_up_param"])},
        .hp_restore_param = {emit_value(u["hp_restore_param"])},
        .pp_restore_param = {emit_value(u["pp_restore_param"])},
        .friendship_mod_lo_param = {emit_value(u["friendship_mod_lo_param"])},
        .friendship_mod_med_param = {emit_value(u["friendship_mod_med_param"])},
        .friendship_mod_hi_param = {emit_value(u["friendship_mod_hi_param"])},
    }},
}},
"""


if __name__ == "__main__":
    ordered = parse_item_constants("include/constants/item.h")

    output_file = "build/itemdata/itemdata.c"
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    with open(output_file, "w", encoding="utf-8") as out:
        out.write(BEGINNING_OF_FILE)
        max_idx_emitted = -1
        for item_macro, _num in ordered:
            folder = folder_name_from_item(item_macro)
            item_json_path = os.path.join("data/itemdata", folder, "item.json")
            if os.path.exists(item_json_path):
                with open(item_json_path, "r", encoding="utf-8") as jf:
                    obj = json.load(jf)
                out.write(emit_item_block(item_macro, obj))
                max_idx_emitted = _num if _num > max_idx_emitted else max_idx_emitted
            else:
                print(f"[ERROR] Missing {item_json_path} â†’ using defaults for {item_macro}")
                exit(1)

        out.write(END_OF_FILE)

    print(f"Processing complete. Saved to '{output_file}'")